## 請說明雜湊跟加密的差別在哪裡，為什麼密碼要雜湊過後才存入資料庫
加密 encrypt：加密是把原文加上金鑰 (key) 後變成密文，只要知道金鑰就可以解開密文。其中最簡單也最廣為人知的例子是「凱薩加密」，以英文的 26 個字母為基礎，把每個英文字母加上某個偏移量 (key) 後變成密文，譬如 dog → jwm (偏移量為 3)。

雜湊 hash： 雜湊是把原文丟進一個不可逆的演算法裡面，最後算出某個值或字串。因為雜湊演算法不可逆的特性，任何人都無法回推出原文，而且同樣的原文 hash 過後一定會得出相同的結果。雜湊是一種多對一的演算法，不同的原文 hash 過後可能得出相同的結果，這種情況叫碰撞 (collision)。越安全的雜湊演算法發生碰撞的機率就越低。SHA256 就是一種目前較常見且安全的雜湊演算法。

密碼經過雜湊才存入資料庫，可以避免網站擁有者或駭客看到使用者的明文密碼，或是知道 key 之後解出使用者的密碼。另外雖然雜湊比加密更安全，但是可以被一種叫做彩虹表的東西破解。彩虹表是一種把雜湊函式逆運算出來的表，把一些常用字 hash 過後的值記起來，破解的時候可以用回推的方式猜出使用者的密碼。所以更安全的做法要「加鹽」。在原本密碼的開頭、結尾或中間加上一個字串，再把密碼丟進雜湊演算法，駭客就很難用彩虹表回推出原始密碼。

## `include`、`require`、`include_once`、`require_once` 的差別
`include` 和 `require` 的功能很像，都可以引入檔案，但 `include` 可以在迴圈中執行，`require` 不行。再來如果它們出錯 (譬如引入一個不存在的檔案或有 bug 的檔案)，`require` 會噴 fatal error 錯誤，終止程式執行，而 `include` 只會出現 warning，程式還是可以繼續跑。

至於 `include_once` 和 `require_once`，顧名思義就是只會引入一次檔案，php 會檢查這個檔案之前有沒有引入過了，如果有就 return true 然後不會再次引入。


## 請說明 SQL Injection 的攻擊原理以及防範方法
原理：
駭客在 user input 裡面注入惡意的 SQL 程式碼，把原本網站設計的 SQL 截斷，改變成另一個意思，就可以存取資料的資料或執行原本沒有權限執行的操作。

防範方法：
使用 SQL 的 prepared statement。Prepared statement 會把一些 sql 的語法當作字串處理，因此駭客無法把原來的 sql 指令截斷，它輸入的程式碼會被解析成字串。

##  請說明 XSS 的攻擊原理以及防範方法
原理：XSS 的全名是 cross-site scripting，跟 SQL injection 一樣都是透過注入惡意程式碼的方式進行攻擊。如果網站的 user input 區塊沒有防範 XSS，那駭客輸入的文字就會被解析成 html tags，也就代表可以在被攻擊的網頁裡面執行 script，把使用者騙到釣魚網站，或偷走使用者的 cookie 之類的。

防範方法：
在顯示任何使用者輸入的資料時，要把文字做特殊處理，讓瀏覽器把那些資料當成純文字處理。在 PHP 裡面可以用 `htmlspecialchars` 這個函數來做。

## 請說明 CSRF 的攻擊原理以及防範方法
原理：CSRF 全名是 cross-site request forgery，攻擊者可以讓使用者在不知情的狀況下從某個網域發送 GET request 到他已經登入的網站。因為使用者登入的網站是靠 cookie 裡面的 PHPSESSID 來判斷登入狀態，所以即使使用者是從另一個網站發送 request，瀏覽器一樣會把這個 request 視為合法。攻擊者可以透過這種方式讓使用者在不知情的狀況下進行某些操作，例如課程範例裡面提到的刪除部落格文章、銀行轉帳等等。

防範方法：
如果是金流這種比較危險的操作，開發者通常會額外加上簡訊驗證或圖形驗證等方式來判斷是不是使用者本人在操作，
但像是刪除部落格文章、編輯留言這種規模的操作就不適合，因為會破壞使用者體驗。不額外做簡訊驗證的話，也可以加上 token，由 server 隨機產生一組 token 並用隱藏的方式加在 form 上面，然後同時在 client 端設定一個叫做 csrftoken 的 cookie，在裡面存同樣的值。最後只要在使用者送出表單的時候，讓程式去檢查兩個 token 的值是否相等，就可以知道這個 request 是從使用者的 form 發出的還是從攻擊者那邊發出的了。

不過現在有一個防範 CSRF 的救星 SameSite，是 Google 開發的功能。我們現在可以在 cookie 裡面帶上 SameSite 參數，瀏覽器就會幫我們判斷某個 request 是不是跨網站請求，如果是就不帶上那個 cookie。這樣就可以擋掉 CSRF 攻擊了。
補充說明，SameSite 有三種模式：none, strict 和 lax。在 strict 模式下，只有 same-site request 才會帶上這個 cookie；在 lax 模式下，則有部分 cross-site request 可以帶上這個 cookie，譬如透過 `<a>`, `<form method="GET">` 或 `<link rel="prerender">` 送出的 request。